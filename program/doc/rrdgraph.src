=include name

=head1 SYNOPSYS

B<rrdtool graph> I<filename>
[E<lt>B<L<option|rrdgraph/OPTIONS>>E<gt> ...]
E<lt>B<L<data definition|rrdgraph_data/DEF>>E<gt>
[E<lt>B<L<data definition|rrdgraph_data/DEF>>E<gt> ...]
[E<lt>B<L<data calculation|rrdgraph_data/CDEF>>E<gt> ...]
[E<lt>B<L<variable definition|rrdgraph_data/VDEF>>E<gt> ...]
[E<lt>B<L<graph element|rrdgraph_graph/GRAPH>>E<gt> ...]
[E<lt>B<L<print element|rrdgraph_graph/PRINT>>E<gt> ...]

=head1 DESCRIPTION

The B<graph> function of B<RRDtool> is used to represent the
data from an B<RRD> to a human viewer.  Its main purpose is to
create a nice graphical representation but it can also generate
a numerical report.

=head1 OVERVIEW

B<rrdtool graph> needs data to work with, use one or more
B<L<data definition|rrdgraph_data/DEF>> statements to collect this
data.  You are not limited to one database, it's perfectly legal to
collect data from two or more databases (one per statement though).

If you want to display averages, maxima, percentiles etcetera
it is best to collect them now using the
B<L<variable definition|rrdgraph_data/VDEF>> statement.  At this
stage, this command works at the unprocessed data from the B<RRD>.
I<(Note: this is not yet true; it works on consolidated information
right now)>

The data fetched from the B<RRA> is then B<consolidated> so that
there is exactly one datapoint per pixel in the graph. If you do
not take care yourself, B<RRDtool> will expand the range slightly
if necessary (in that case the first pixel may very well become
unknown!).

Sometimes data is not exactly as you would like to display it. For
instance, you might be collecting B<bytes> per second but want to
display B<bits> per second. This is where the
B<L<data calculation|rrdgraph_data/CDEF>> command is designed for.
After B<consolidating> the data, a copy is made and this copy is
modified using a rather flexible B<L<RPN|rrdgraph_rpn/>> command
set.  If you use B<L<variable definition|rrdgraph_data/VDEF>>
statements after this, they work on the consolidated data and may
return other values for maximum, minimum etcetera!

When you are done fetching and processing the data, it is time to
graph it (or print it).  This ends the B<rrdtool graph> sequence.

=head1 OPTIONS

It is expected that most options will move to the graph definition
statements (after all, most of them do define graph elements...).

=over 4

=item filename

The name and path of the graph to generate. It is recommended to
end this in C<.png> or C<.gif> but B<rrdtool> does not enforce this.

I<filename> can be 'C<->' to send the image to C<stdout>. In
that case, no other output is generated.  

Z<>

=item Time range

B<[-s|--start E<lt>timeE<gt>]>
B<[-e|--end E<lt>timeE<gt>]>
B<[--step E<lt>secondsE<gt>]>

The start and end of what you would like to display, and which
B<RRA> the data should come from.  Defaults are: 1 day ago until
now, with the best possible resolution. B<Start> and B<end> can 
be specified in several formats, see
L<AT-STYLE TIME SPECIFICATION|rrdfetch/> and L<rrdgraph_examples>.
By default, B<rrdtool graph> calculates the width of one pixel in
the time domain and tries to get data from an B<RRA> with that
resolution.  With the B<step> option you can alter this behaviour.
If you want B<rrdtool graph> to get data at a one-hour resolution
from the B<RRD>, set B<step> to 3600.  Note: a step smaller than
one pixel will silently be ignored.

Z<>

=item Labels

B<[-t|--title E<lt>stringE<gt>]>
B<[-v|--vertical-label E<lt>stringE<gt>]>

A horizontal string at the top of the graph and/or a vertically
placed string at the left hand side of the graph. I<New: (not
yet implemented)> The string can contain formatter options that
are used to include variables (from B<VDEF>s) and newlines.

Z<>

=item Size

B<[-w|--width E<lt>pixelsE<gt>]>
B<[-h|--heigth E<lt>pixelsE<gt>]>

The width and height of the B<canvas> (the part of the graph with
the actual lines and such). Defaults are 400 pixels by 100 pixels.

Z<>

=item Limits

I<Old behaviour, until the new options are implemented>
B<[-u|--upper-limit E<lt>valueE<gt>]>
B<[-l|--lower-limit E<lt>valueE<gt>]>
B<[-r|--rigid]>

By default the graph will be autoscaling so that it displays the
portion of the y-axis that is actually used. You can change this
behaviour by setting the limits.  The displayed y-axis will show
at least from B<lower-limit> to B<upper-limit>.  Autoscaling will
still permit those boundaries to be stretched unless the B<rigid>
option is set.

I<New behaviour, after the new options are implemented>
B<[--maximum-upper-limit E<lt>valueE<gt>]>
B<[--minimum-upper-limit E<lt>valueE<gt>]>
B<[--maximum-lower-limit E<lt>valueE<gt>]>
B<[--minimum-lower-limit E<lt>valueE<gt>]>

By default the graph will be autoscaling so that it displays the
portion of the y-axis that is actually used. You can change this
behaviour by setting the limits.  The displayed y-axis will show
at most B<maximum-upper-limit> and at least B<minimum-upper-limit>
at the top, and similarily at least B<maximum-lower-limit> and
at most B<minimum-lower-limit> at the bottom.  The default is to
display at most B<infinity> (so: no limit) and at least
B<negative infinity> (no minimal value) at the top. The bottom of
the graph has similar defaults. Note that the minimum lower limit
is the lowest one so you should compare this with maximum upper
limit when you try to figure out what you should set.

To make sure the graph shows the range of I<-1000> to I<2000>,
optionally expanding to no more than I<-3000> to I<4000>,
set the following options:

--maximum-upper-limit 4000 --minimum-upper-limit 2000
--maximum-lower-limit -1000 --minimum-lower-limit -3000

To mimic the old B<rigid> option, you can do:

--maximum-upper-limit 4000 --minimum-upper-limit 4000
--maximum-lower-limit -3000 --minimum-lower-limit -3000

B<[--alt-autoscale]>

Sometimes the default algorithm for selecting the y-axis scale is not
performing very well.  Normally the scale is selected from a predefined
set of ranges and this fails miserably when you need to graph something
like C<260 + 0.001 * sin(x)>. This option calculates the minimum and
maximum y-axis from the actual minimum and maximum values. Our example
would display slightly less than C<260-0.001> to slightly more than
C<260+0.001> (Contributed by Sasha Mikheev).

B<[--alt-autoscale-max]>

Where C<--alt-autoscale> will modify both the absolute maximum AND minimum
values, this option will only affect the maximum value. The minimum
value, if not defined on the command line, will be 0. This option can
be useful when graphing router traffic when the WAN line uses compression,
and thus the throughput may be higher than the WAN line speed.

Z<>

=item Grid

=over 4

=item X-Axis

B<[-x|--x-grid E<lt>I<GTMC<:>GSTC<:>MTMC<:>MSTC<:>LTMC<:>LSTC<:>LPRC<:>LFM>E<gt>|C<none>]>

The x-axis label is quite complex to configure, if you don't have
very special needs it is probably best to rely on the autoconfiguration
to get this right.  You can specify the string C<none> to skip the grid
and labels altogether.

The grid is defined by specifying a certain amount of time in the I<?TM>
positions. You can choose from C<SECOND>, C<MINUTE>, C<HOUR>, C<DAY>,
C<WEEK>, C<MONTH> or C<YEAR>. Then you define how many of these should
pass between each line or label.  This pair (I<?TM:?ST>) needs to be
specified for the base grid (I<G??>), the major grid (I<M??>) and the
labels (I<L??>). For the labels you also need to define a precision
in I<LPR> and a I<strftime> format string in I<LFM>.  I<LPR> defines
where each label will be placed. If it is zero, the label will be
placed right under the corresponding line (useful for hours, dates
etcetera).  If you specify a number of seconds here the label is
centered in this interval (useful for monday, januari etcetera).

Example: C<--x-grid MINUTE:10:HOUR:1:HOUR:4:0:%X>

This places grid lines every 10 minutes, major grid lines every hour
and labels every 4 hours. The labels are placed under the major grid
lines as they specify exactly that time.

Example: C<--x-grid HOUR:8:DAY:1:DAY:1:0:%A>

This places grid lines every 8 hours, major grid lines and labels
each day. The labels are placed exactly between two major grid lines
as they specify the complete day and not just midnight.

Z<>

=item Y-Axis

B<[-y|--y-grid I<E<lt>grid stepE<gt>:E<lt>label factorE<gt>>|C<none>]>

Y-axis grid lines appear at each I<grid step> interval.  Labels are
placed every I<label factor> lines.  You can specify C<-y none> to
skip the grid and labels altogether.  The default for this option is
to automatically select sensible values.

B<[--alt-y-grid]>

Place Y grid dynamically based on graph Y range. Algorithm ensures
that you always have grid, that there are enough but not too many
grid lines and the grid is metric. That is grid lines are placed
every 1, 2, 5 or 10 units.  (contributed by Sasha Mikheev)

B<[-o|--logarithmic]>

Logarithmic y-axis scaling.

B<[--units-exponent E<lt>valueE<gt>]>

This sets the 10**exponent scaling of the y-axis values.  Normally
values will be scaled to the appropriate units (k, M, etc.).  However
you may wish to display units always in k (Kilo, 10e3) even if the data
is in the M (Mega, 10e6) range for instance.  Value should be an
integer which is a multiple of 3 between -18 and 18 inclusive.  It is
the exponent on the units you which to use.  For example, use 3 to
display the y-axis values in k (Kilo, 10e3, thousands), use -6 to
display the y-axis values in u (Micro, 10e-6, millionths).  Use a value
of 0 to prevent any scaling of the y-axis values.

Z<>

=back

Z<>

=item Miscellaneous

B<[-z|--lazy]>

Only generate the graph, if the current graph is out of date or not
existent.

B<[-f|--imginfo E<lt>printfstrE<gt>]>

After the image has been created, the graph function uses printf
together with this format string to create output similar to the PRINT
function, only that the printf is supplied with the parameters
I<filename>, I<xsize> and I<ysize>. In order to generate an B<IMG> tag
suitable for including the graph into a web page, the command line
would look like this:

    --imginfo '<IMG SRC="/img/%s" WIDTH="%lu" HEIGHT="%lu" ALT="Demo">'

B<[-c|--color I<COLORTAGBB<#>I<rrggbb>B<[>I<aa>B<<]>

Override the default colors for the standard elements of the graph.
The I<COLORTAG> is one of C<BACK> ground, C<CANVAS>, C<SHADEA> for the
left and top border, C<SHADEB> for the right and bottom border, C<GRID>,
C<MGRID> for the major grid, C<FONT>, C<FRAME> and axis, C<ARROW>.
Each color is composed out of three hexadecimal numbers specifying
its color component (00 is off, FF is maximum) of red, green and blue.
You may set this option several times to alter multiple defaults.

A green arrow is made by: C<--color ARROW:00FF00>

B<--zoom> I<factor>

Zoom the graphics by the given amount ... The factor must be > 0

B<[-n|--font I<FONTTAG>B<:>I<size>B<:>I<font>

Lets you customize which font to use for the various text elements on the
rrd graphs. C<DEFAULT> sets the default value for all elements C<TITLE>,
C<AXIS> for the axis labels, C<UNIT> for the vertical unit label, C<LEGEND>
for the graph legend.

Use Times for the title: C<--font TITLE:13:/usr/lib/fonts/times.ttf>

B<[-a|--imgformat C<PNG>]>

At present only PNG is supported, but C<EPS>, C<SVG> or even C<FLASH> should
not be all that difficult to add.

B<[-i|--interlaced]>

The default is to generate a non-interlaced GIF image. It is recommended
to generate PNG graphics as they take up to 40% less disk space and
20-30% less time to generate.

B<[-g|--no-legend]>

Suppress generation of legend; only render the graph.

B<[-b|--base E<lt>valueE<gt>]>

If you are graphing memory (and NOT network traffic) this switch
should be set to 1024 so that one Kb is 1024 byte. For traffic
measurement, 1 kb/s is 1000 b/s.

Z<>

=item Data and variables

B<DEF:>I<E<lt>vnameE<gt>>=I<E<lt>rrdfileE<gt>>:I<E<lt>ds-nameE<gt>>:I<E<lt>CFE<gt>>[:[I<E<lt>time rangeE<gt>>][:I<E<lt>step timeE<gt>>]]

B<CDEF:>I<E<lt>vnameE<gt>>=I<E<lt>RPN expressionE<gt>>

B<VDEF:>I<E<lt>vnameE<gt>>=I<E<lt>RPN expressionE<gt>>

You need at least one B<DEF> statement to generate anything. The
other statements are useful but optional.
See L<rrdgraph_data> and L<rrdgraph_rpn> for exact format.

Z<>

=item Graph and print elements

You need at least one graph element to generate an image and/or
at least one print statement to generate a report.
See L<rrdgraph_graph> for exact format.

=back

=include see_also
